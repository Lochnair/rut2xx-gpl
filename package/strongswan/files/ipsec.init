#!/bin/sh /etc/rc.common
#/etc/init.d/ipsec - version 1 2015-10-01

NAME=ipsec

START=90
STOP=10

. /lib/functions.sh
ENABLED=0
KERNEL_LIB=0
TRANSPORT=0

File_ipsec="/tmp/ipsec/ipsec.conf"
File_secrets="/tmp/ipsec/ipsec.secrets"
File_strongswan="/tmp/ipsec/strongswan.conf"
File_firewall="/tmp/ipsec/firewall.sh"

LAN_IP="0.0.0.0/0"
firewall_webui_rule=""

fix_wan(){
	local name
	local section="$1"
	local action="$2"
	local subnets="$3"

	config_get name "$section" name

	[ "$name" = "wan" ] && {
		if [ "$action" = "add" ]; then
			for sub in $subnets; do
				uci add_list firewall."$section".masq_dest="!$sub"
			done
		else
			uci delete firewall."$section".masq_dest
		fi
	}

	uci_commit firewall
}

checkifenabled() {
	config_get_bool enabled "$1" 'enabled' 0
	if [ $enabled -eq 1 ]; then
		ENABLED=1
	fi
}

checkpsk() {
    config_get psk_key "$1" 'psk_key' "0"
    if [ $psk_key != "0" ]; then
        uci del strongswan."$1".psk_key
        code=`uci add strongswan preshared_keys`
        uci set strongswan."$code".psk_key="$psk_key"
        uci set strongswan."$code".id_selector='%any'
        uci commit strongswan
    fi
}
checkiftransport() {
	config_get ipsec_type	"$1" ipsec_type "tunnel"
	if [ "$ipsec_type" = "transport" ]; then
		TRANSPORT=1
	fi
}

prepare_ipsec_config() {
	echo "# generated by /etc/init.d/ipsec" >"$File_ipsec"
	echo "conn %default"  >>"$File_ipsec"
	echo "	rekeymargin=3m" >>"$File_ipsec"
	echo "" >>"$File_ipsec"
}

prepare_passthrough_section() {
    for i in $(seq 0 $(( $count - 1))); do
	    echo "conn passthrough$i"  >>"$File_ipsec"
	    eval echo "\	leftsubnet=\${LANP_IP$i}" >>"$File_ipsec"
	    eval echo "\	rightsubnet=\${LANP_IP$i}" >>"$File_ipsec"
	    echo "	type=passthrough" >>"$File_ipsec"
	    echo "	authby=never" >>"$File_ipsec"
	    echo "	auto=route" >>"$File_ipsec"
	    echo "" >>"$File_ipsec"
	done
}

KeepAlive () {
	local address
	local period
	local keep_enabled
	local iface

	config_get keep_enabled "$1" keep_enabled "0"

	if [ "$keep_enabled" -eq 1 ]; then
		config_get address	"$1"	ping_ipaddr
		config_get period	"$1"	ping_period
		iface=`uci get -q network.lan.ipaddr`

		/sbin/keep_alive.sh $address $period $iface &
	fi
}

ConfigPskKeys() {
	auth="psk"

	config_get id_selector	"$1" id_selector ""
	config_get psk_key	"$1" psk_key

	if [ "$auth" == "psk" ]; then
		echo "$id_selector : PSK \"$psk_key\" " >>"$File_secrets"       # There must be whitespaces around the colon
	fi
}

Multiwan_IP_Parse() {
	primary_wan=`cat /tmp/.mwan/cache | grep 'wan_if_map' | awk -F '[' '{ print $2 }' | awk -F ']' '{ print $1 }'`
	secondary_wan=`cat /tmp/.mwan/cache | grep 'wan_if_map' | awk -F '[' '{ print $3 }' | awk -F ']' '{ print $1 }'`
	failed_wan=`cat /tmp/.mwan/cache  | grep 'wan_fail_map' | awk -F '"' '{ print $2 }' | awk -F '[' '{ print $1 }'`
	if [ "$failed_wan" == "wan" ]; then
	    get_ip_addr=`/sbin/ifconfig $secondary_wan | grep 'inet addr' | cut -d: -f2 | awk '{print $1}'`
	elif [ "$failed_wan" == "wan2" -o "$failed_wan" == "" ]; then
	    get_ip_addr=`/sbin/ifconfig $primary_wan | grep 'inet addr' | cut -d: -f2 | awk '{print $1}'`
	fi

	echo $get_ip_addr
}

ConfigRemote() {
	config_get_bool enabled "$1" enabled 0
	[[ "$enabled" == "0" ]] && return

	auth="psk"
	config_get my_identifier_type	"$1" my_identifier_type ""
	config_get keyexchange	"$1" keyexchange "ikev1"
	config_get leftid	"$1" my_identifier ""
	config_get leftsubnet	"$1" leftsubnet ""
	config_get leftfirewall	"$1" leftfirewall "yes"

	config_get right	"$1" right ""
	config_get rightid	"$1" rightid ""
	config_get rightsubnet	"$1" rightsubnet
	config_get rightfirewall	"$1" rightfirewall "yes"
	config_get aggressive	"$1" aggressive
	config_get auto	"$1" auto "start"
	config_get ipsec_type	"$1" ipsec_type "tunnel"
	config_get forceencaps	"$1" forceencaps ""
	config_get dpdaction	"$1" dpdaction
	config_get dpddelay		"$1" dpddelay "30"
	config_get dpdtimeout	"$1" dpdtimeout "150"

	config_get ike_encryption_algorithm	"$1" ike_encryption_algorithm
	config_get ike_authentication_algorithm	"$1" ike_authentication_algorithm
	config_get ike_dh_group			"$1" ike_dh_group
	config_get ikelifetime			"$1" ikelifetime "1h"

	config_get esp_encryption_algorithm	"$1" esp_encryption_algorithm
	config_get esp_hash_algorithm		"$1" esp_hash_algorithm
	config_get esp_pfs_group		"$1" esp_pfs_group
	config_get keylife			"$1" keylife "8h"

	config_get allow_webui "$1" allow_webui "0"

	multiwan=`uci -q get multiwan.config.enabled`
    if [ "$multiwan" == "1" ]; then
        if [ -f /tmp/.mwan/cache ]; then
            get_ip_addr=`Multiwan_IP_Parse`
        else
            logger -t "IPSec.init" "File .mwan/cache not found. Restarting multiwan."
            /etc/init.d/multiwan restart
            inc=0
            while [ ! -f /tmp/.mwan/cache ] && [ $inc -le 9 ]; do
                inc=$(( inc + 1 ))
                sleep 1
            done
            get_ip_addr=`Multiwan_IP_Parse`
        fi
    else
        get_ip_addr="%any"
    fi

	echo "conn $1" >>"$File_ipsec"

	if [ "$multiwan" == "1" ]; then
            echo "        left=$get_ip_addr" >>"$File_ipsec"
	else
            echo "        left=$get_ip_addr" >>"$File_ipsec"
	fi

	if [ "$my_identifier_type" == "fqdn" ]; then
		leftid="@$leftid"
	elif [ "$my_identifier_type" == "user_fqdn" ]; then
		leftid="@@$leftid"
	elif [ "$my_identifier_type" == "address" ]; then
		leftid="$leftid"
	else
		leftid="%any"
	fi

	echo "	leftid=$leftid" >>"$File_ipsec"
	if [ "$ipsec_type" = "tunnel" ]; then
		if [ "$leftsubnet" = "" ]; then
			echo "	leftsubnet=$LAN_IP" >>"$File_ipsec"
		else
			left_item=0
			for item in $leftsubnet
			do
				if [ "$left_item" = "0" ]; then
					echo -n "	leftsubnet=$item" >>"$File_ipsec"
				else
					echo -n ",$item" >>"$File_ipsec"
				fi
				left_item=$(( $left_item + 1 ))
			done
			echo "" >>"$File_ipsec"
		fi
	else
		echo "	leftprotoport=udp/l2tp" >>"$File_ipsec"
		echo "	rightprotoport=udp/%any" >>"$File_ipsec"
	fi
	echo "	leftauth=$auth" >>"$File_ipsec"
	echo "	rightauth=$auth" >>"$File_ipsec"
	if [ "$right" != "" ]; then
		echo "	right=$right" >>"$File_ipsec"
		echo "	closeaction=restart" >>"$File_ipsec"
	else
		echo "	right=%any" >>"$File_ipsec"
	fi

	if [ "$rightid" != "" ]; then
		echo "	rightid=$rightid" >>"$File_ipsec"
	else
		echo "	rightid=%any" >>"$File_ipsec"
	fi

	echo "	keyexchange=$keyexchange" >>"$File_ipsec"
	echo "	authby=secret" >>"$File_ipsec"
	echo "	leftfirewall=$leftfirewall" >>"$File_ipsec"
	echo "	rightfirewall=$rightfirewall" >>"$File_ipsec"
	echo "	auto=$auto" >>"$File_ipsec"
	echo "	type=$ipsec_type" >>"$File_ipsec"
	echo "	aggressive=$aggressive" >>"$File_ipsec"

	echo "	dpdaction=$dpdaction" >>"$File_ipsec"
	echo "	dpddelay=$dpddelay" >>"$File_ipsec"
	echo "	dpdtimeout=$dpdtimeout" >>"$File_ipsec"
	echo "	forceencaps=$forceencaps" >>"$File_ipsec"
	echo "	keyingtries=%forever" >>"$File_ipsec"

	echo "	ike=$ike_encryption_algorithm-$ike_authentication_algorithm-$ike_dh_group" >>"$File_ipsec"
	echo "	ikelifetime=$ikelifetime" >>"$File_ipsec"

	if [ "$esp_pfs_group" == "no_pfs" ]; then
		echo "	esp=$esp_encryption_algorithm-$esp_hash_algorithm" >>"$File_ipsec"
	else
		echo "	esp=$esp_encryption_algorithm-$esp_hash_algorithm-$esp_pfs_group" >>"$File_ipsec"
	fi
	echo "	keylife=$keylife" >>"$File_ipsec"
	for item in $custom
	do
		echo "	$item" >> "$File_ipsec"
	done

	right_item=0

	for item in $rightsubnet
	do
		if [ $item == "0.0.0.0/0" ]; then
			KERNEL_LIB=1
		fi

		#Get list of remote subnets
		append remote_subnets "$item"

		enable_disable_ipsec_webui_rule $allow_webui $item

		if [ $right_item -eq 0 ]; then
			if [ "$keyexchange" = "ikev2" ]; then
				printf "	rightsubnet=$item" >>"$File_ipsec"
			else
				echo "	rightsubnet=$item" >>"$File_ipsec"
				echo "" >>"$File_ipsec"
			fi
		else
			if [ "$keyexchange" = "ikev2" ]; then
				printf ",$item" >>"$File_ipsec"
			else
				echo "conn $1_$right_item" >>"$File_ipsec"
				echo "	also=$1" >>"$File_ipsec"
				echo "	rightsubnet=$item" >>"$File_ipsec"
				echo "" >>"$File_ipsec"
			fi
		fi
		right_item=$(( $right_item + 1 ))
	done
	echo "" >>"$File_ipsec"
	KeepAlive "$1"
}

get_name() {
	rule_name='Enable_IPsec_WebUI'
	name=$(uci get firewall.$1.name)
	[ "$rule_name" != "$name" ] && return
	firewall_webui_rule=$1
}

# For some reason config_set does not work here.
create_ipsec_webui_rule() {
	section=$(uci add firewall rule)
	uci set firewall.$section.name="Enable_IPsec_WebUI"
	uci set firewall.$section.src="wan"
	uci set firewall.$section.proto="tcp"
	uci set firewall.$section.src_ip=$1
	uci set firewall.$section.dest_ip=$LAN_IP
	uci set firewall.$section.dest_port="80 443"
	uci set firewall.$section.target="ACCEPT"
	uci set firewall.$section.enabled="1"
	uci set firewall.$section.extra="-m policy --dir in --pol ipsec --mode tunnel --tunnel-dst 0.0.0.0/0 --tunnel-src 0.0.0.0/0"
}

enable_disable_ipsec_webui_rule() {
	config_load "firewall"
	config_foreach get_name "rule"
	section="$firewall_webui_rule"
	if [ "$section" != "" ]; then
		uci set firewall.$section.enabled=$1
	elif [ "$1" == "1" ]; then
		create_ipsec_webui_rule $2
	fi
}

prepare_strongswan_config(){
	echo "charon {" >"$File_strongswan"
	if [ $KERNEL_LIB -eq 0 ]; then
		echo "	load = charon aes des rc2 sha1 sha2 md5 random nonce x509 revocation constraints pubkey pkcs1 pgp dnskey sshkey pem fips-prf gmp xcbc hmac attr kernel-netlink resolve socket-default stroke updown xauth-generic" >>"$File_strongswan"
	else
		echo "	load = charon aes des rc2 sha1 sha2 md5 random nonce x509 revocation constraints pubkey pkcs1 pgp dnskey sshkey pem fips-prf gmp xcbc hmac attr kernel-netlink resolve socket-default stroke updown xauth-generic kernel-libipsec" >>"$File_strongswan"
	fi
	echo "	i_dont_care_about_security_and_use_aggressive_mode_psk = yes" >>"$File_strongswan"
	echo "}" >>"$File_strongswan"
}

check_lan_ip() {
	lans=`route -n | grep br-lan`
	OLD_IFS=$IFS
	IFS=$'\n'
	count=0
	for lan in $lans
	do
		br_lan=`echo $lan | awk -F ' ' '{print $1}'`
		lan_netmask=`echo $lan | awk -F ' ' '{print $3}'`
		lan_prefix=`ipcalc.sh $br_lan $lan_netmask | grep PREFIX | awk -F '=' '{print $2}'`
		if [ "$LAN_IP" == "0.0.0.0/0" ]; then
			LAN_IP="$br_lan/$lan_prefix"
			eval LANP_IP$count=$LAN_IP
			count=$(( $count + 1 ))
		else
			LAN_IP="$LAN_IP,$br_lan/$lan_prefix"
			eval LANP_IP$count="$br_lan/$lan_prefix"
			count=$(( $count + 1 ))
		fi
	done
	IFS=$OLD_IFS
}

start() {
	config_load 'strongswan'
	config_foreach checkpsk 'conn'
	config_foreach checkifenabled 'conn'
	[ $ENABLED -eq 0 ] && return 1

	mkdir -p /tmp/ipsec/
	echo "# generated by /etc/init.d/ipsec" >"$File_secrets".
	config_foreach checkiftransport 'conn'
	check_lan_ip
	prepare_ipsec_config
	if [ "$TRANSPORT" = "0" ]; then
		prepare_passthrough_section
	fi
	echo "# generated by /etc/init.d/ipsec" >"$File_firewall"
	config_foreach ConfigRemote 'conn'
	config_load 'strongswan'
	config_foreach ConfigPskKeys 'preshared_keys'
	prepare_strongswan_config

	config_load firewall
	config_foreach fix_wan zone "add" "$remote_subnets"
	/usr/sbin/ipsec start
}

reload() {
	stop
	start
}

stop() {
	/usr/sbin/ipsec stop
        kill `ps ww | grep -v init.d | awk '/\/ipsec\//{print $1}'` 2> /dev/null
	rm -f "$File_firewall" "$File_secrets" "$File_ipsec"
	config_load firewall
	config_foreach fix_wan zone "remove"
}
